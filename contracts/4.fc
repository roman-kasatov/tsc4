{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

(builder, ()) store_letter(builder b, int letter) asm(letter b) "8 STU";

int map_get(slice mapping, int x) inline asm """
  8 MULINT
  SDSKIPFIRST
  8 PLDU
""";

(builder, ()) store_rotated_slice(builder b, slice slc, int shift) inline asm """
  8 MULINT
  ZERO
  SPLIT
  ROT
  STSLICE
  STSLICE
""";

(slice) create_mapping(int shift) inline {
  builder dct = begin_cell();
  dct = dct.store_slice("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40"s);
  dct~store_rotated_slice("4142434445464748494a4b4c4d4e4f505152535455565758595a"s, shift); ;; A-Z 65-90
  dct = dct.store_slice("5b5c5d5e5f60"s);
  dct~store_rotated_slice("6162636465666768696a6b6c6d6e6f707172737475767778797a"s, shift); ;; a-z 97-122
  return dct.end_cell().begin_parse();
}


(slice, builder) shift_slice(slice slc, builder out, slice map) inline {
  repeat (slc.slice_bits() / 8) {
    int letter = slc~load_uint(8);
    if (letter > 122) {
      out~store_letter(letter);
    } else {
      out = out.store_uint(map.map_get(letter), 8);
    }
  }
  return (slc, out);
}

(cell) shift_text(cell text, slice map) inline {
  tuple stack = null();
  slice slc = text.begin_parse();

  int depth = slc.slice_depth();

  repeat (depth) {
    stack~push_back(slc);
    slc = slc~load_ref().begin_parse();
  }

  builder out = begin_cell();
  (slc, out) = shift_slice(slc, out, map);

  cell tail = out.end_cell();

  repeat (depth) {
    out = begin_cell();
    slc = stack~pop_back();

    (slc, out) = shift_slice(slc, out, map);

    out = out.store_ref(tail);
    tail = out.end_cell();
  }

  return tail;
}


;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  return shift_text(text, create_mapping(shift % 26));
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  return shift_text(text, create_mapping((- shift) % 26));
}
