{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

(builder, ()) store_letter(builder b, int letter) asm(letter b) "8 STU";


;; A-Z 65-90
;; a-z 97-122
(tuple) create_mapping(int shift) asm """
  DUP
  1 PUSHINT
  89 PUSHINT
  REPEAT:<{
    TUCK
    INC
  }>

  s1 s0 XCPU
  ISPOS
  IF:<{
    DUP
    26 PUSHINT
    SUBR
    BLKSWX
  }>

  91 PUSHINT
  31 PUSHINT
  REPEAT:<{
    DUP
    INC
  }>

  ZERO
  s0 123 s() XCHG
  DUP
  ISPOS
  IF:<{
    DUP
    26 PUSHINT
    SUBR
    BLKSWX
  }>

  123 PUSHINT
  130 PUSHINT
  REPEAT:<{
    DUP
    INC
  }>

  TUPLEVAR
""";


(slice, builder) shift_slice(slice slc, builder out, tuple map) inline {
  repeat (slc.slice_bits() / 8) {
    int letter = slc~load_uint(8);
    if (letter > 122 ) {
      out~store_letter(letter);
    } else {
      out~store_letter(map.at(letter));
    }
  }
  return (slc, out);
}

(cell) shift_text(cell text, int shift) inline {
  shift %= 26;
  tuple map = create_mapping(shift);
  tuple stack = null();
  slice slc = text.begin_parse();

  int depth = slc.slice_depth();


  repeat (depth) {
    stack~push_back(slc);
    slc = slc~load_ref().begin_parse();
  }

  builder out = begin_cell();
  (slc, out) = shift_slice(slc, out, map);

  cell tail = out.end_cell();

  repeat (depth) {
    out = begin_cell();
    slc = stack~pop_back();

    (slc, out) = shift_slice(slc, out, map);

    out = out.store_ref(tail);
    tail = out.end_cell();
  }

  return tail;
}


;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  return shift_text(text, shift);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  return shift_text(text, - shift);
}
